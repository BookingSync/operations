# frozen_string_literal: true

# This module contains helpers for simplifaction of testing
# of operation-related concerns.
#
# @example
#   require "operations/test_helpers"
#
#   module RailsHelper
#     config.include Operations::TestHelpers
#   end
module Operations::TestHelpers
  def self.empty_contract
    @empty_contract ||= OperationContract.build { schema { nil } }
  end

  # Used to test messages generated by preconditions
  # If one calls `precondition.call` intests and it returns `Failure`
  # there is no way to check is a proper text message will be rendered.
  #
  # @example
  #   subject(:precondition) { described_class::Precondition.new }
  #   let(:contract) { described_class::Contract.new }
  #
  #   describe "#call" do
  #     subject(:errors) { precondition_errors(precondition, contract, **context) }
  #
  #     let(:context) { { entity: entity } }
  #
  #     context "when entity is pokable" do
  #       let(:entity) { build_stubbed(:entity) }
  #
  #       it { is_expected.to be_empty }
  #     end
  #
  #     context "when entity is not pokable" do
  #       let(:entity) { build_stubbed(:entity) }
  #
  #       specify do
  #         expect(errors).to eq({
  #           nil => [{ code: :some_failure, text: "Unable to poke entity" }]
  #         })
  #       end
  #     end
  #   end
  #
  # We need to pass contract since preconditions are using the
  # contract's message rendering and we want to ensure that the
  # translation is placed correctly in the scope of the operation.
  def precondition_errors(precondition, contract = Operations::TestHelpers.empty_contract, **context)
    component = Operations::Components::Preconditions.new(
      [precondition],
      message_resolver: contract.message_resolver
    )
    result = component.call({}, context)
    result.errors.to_h
  end

  # Works exactly the same way as {#precondition_errors} but
  # for policies.
  #
  # @see #precondition_errors
  def policy_errors(policy, contract = Operations::TestHelpers.empty_contract, **context)
    component = Operations::Components::Policies.new(
      [policy],
      message_resolver: contract.message_resolver
    )
    result = component.call({}, context)
    result.errors.to_h
  end
end
